{
  "language": "Solidity",
  "sources": {
    "contracts/GameContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n// Minimal interfaces for the tokens we need to interact with.\ninterface IERC20Mintable {\n    function mint(address to, uint256 amount) external;\n}\n\ninterface IERC20Burnable {\n    function burn(address from, uint256 amount) external;\n}\n\ninterface IERC20Transferable {\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n}\n\n// Ownable contract for access control\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) { return msg.sender; }\n}\n\nabstract contract Ownable is Context {\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    constructor(address initialOwner) { _transferOwnership(initialOwner); }\n    function owner() public view virtual returns (address) { return _owner; }\n    modifier onlyOwner() { require(owner() == _msgSender(), \"Ownable: caller is not the owner\"); _; }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n/**\n * @title GameContract\n * @dev Manages locking of WarpedParsDToken and distribution of UGameToken rewards.\n */\ncontract GameContract is Ownable {\n    // --- State Variables ---\n\n    IERC20Transferable public immutable warpedToken;  // The token to be locked (wDT)\n    IERC20Mintable public immutable lockToken;         // The receipt token for the game (LUGAME)\n    IERC20Burnable public immutable lockTokenBurner;    // Same as lockToken, but using a burnable interface\n    IERC20Mintable public immutable rewardToken;       // The reward token (UGAME)\n\n    uint256 public constant REWARDS_PER_DAY = 10 * 1e18; // 10 UGAME tokens per day\n    uint256 public constant TIME_PERIOD = 24 hours;\n    \n    uint256 public rewardPerTokenStored;\n    uint256 public lastUpdateTime;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n\n    // --- Events ---\n    event Locked(address indexed user, uint256 amount);\n    event Unlocked(address indexed user, uint256 amount);\n    event RewardClaimed(address indexed user, uint256 amount);\n    event RewardsDistributed(uint256 reward);\n\n    // --- Constructor ---\n\n    constructor(\n        address _warpedTokenAddress,\n        address _lockTokenAddress,\n        address _rewardTokenAddress,\n        address _initialOwner\n    ) Ownable(_initialOwner) {\n        warpedToken = IERC20Transferable(_warpedTokenAddress);\n        lockToken = IERC20Mintable(_lockTokenAddress);\n        lockTokenBurner = IERC20Burnable(_lockTokenAddress);\n        rewardToken = IERC20Mintable(_rewardTokenAddress);\n        lastUpdateTime = block.timestamp;\n    }\n\n    // --- Modifiers ---\n    \n    modifier updateReward(address _account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = block.timestamp;\n        rewards[_account] = earned(_account);\n        userRewardPerTokenPaid[_account] = rewardPerTokenStored;\n        _;\n    }\n\n    // --- View Functions for Rewards ---\n\n    function rewardPerToken() public view returns (uint256) {\n        uint256 totalLockSupply = warpedToken.totalSupply();\n        if (totalLockSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        return rewardPerTokenStored + ((block.timestamp - lastUpdateTime) * REWARDS_PER_DAY * 1e18) / (TIME_PERIOD * totalLockSupply);\n    }\n\n    function earned(address _account) public view returns (uint256) {\n        return (warpedToken.balanceOf(_account) * (rewardPerToken() - userRewardPerTokenPaid[_account])) / 1e18 + rewards[_account];\n    }\n    \n    // --- Core Logic Functions (Callable only by Hub) ---\n    \n    function lock(address _user, uint256 _amount) external onlyOwner updateReward(_user) {\n        require(_amount > 0, \"GameContract: Cannot lock 0 tokens\");\n        // Pull wDT tokens from the user into this contract\n        warpedToken.transferFrom(_user, address(this), _amount);\n        // Mint an equal amount of LUGAME tokens for the user as a receipt\n        lockToken.mint(_user, _amount);\n        emit Locked(_user, _amount);\n    }\n    \n    function unlock(address _user, uint256 _amount) external onlyOwner updateReward(_user) {\n        require(_amount > 0, \"GameContract: Cannot unlock 0 tokens\");\n        // Burn the user's LUGAME receipt tokens\n        lockTokenBurner.burn(_user, _amount);\n        // Return the wDT tokens to the user\n        warpedToken.transfer(_user, _amount);\n        emit Unlocked(_user, _amount);\n    }\n\n    // --- Public Functions ---\n    \n    /**\n     * @dev Distributes rewards for the past period. Can be called by anyone.\n     */\n    function distributeRewards() public {\n        require(block.timestamp >= lastUpdateTime + TIME_PERIOD, \"GameContract: 24 hours have not passed\");\n        uint256 totalLockSupply = warpedToken.totalSupply();\n        if (totalLockSupply > 0) {\n            uint256 reward = (block.timestamp - lastUpdateTime) * REWARDS_PER_DAY / TIME_PERIOD;\n            rewardPerTokenStored = rewardPerTokenStored + (reward * 1e18 / totalLockSupply);\n            lastUpdateTime = block.timestamp;\n            // Mint new reward tokens and keep them in this contract for users to claim\n            rewardToken.mint(address(this), reward);\n            emit RewardsDistributed(reward);\n        }\n    }\n\n    /**\n     * @dev Allows a user to claim their accumulated rewards.\n     */\n    function claimReward() public updateReward(msg.sender) {\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            IERC20Transferable(address(rewardToken)).transfer(msg.sender, reward);\n            emit RewardClaimed(msg.sender, reward);\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {}
  }
}