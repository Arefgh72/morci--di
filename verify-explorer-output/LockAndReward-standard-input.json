{
  "language": "Solidity",
  "sources": {
    "contracts/LockAndReward.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n// --- Interfaces, Libraries, and Base Contracts ---\n\ninterface IGGOToken {\n    function mint(address to, uint256 amount) external;\n}\n\nlibrary Counters {\n    struct Counter {\n        uint256 _value;\n    }\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n}\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n}\n\ninterface IERC165 {\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\nabstract contract ERC165 is IERC165 {\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\ninterface IERC721Metadata {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\ninterface IERC721Receiver {\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}\n\ninterface IERC721 is IERC165 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function setApprovalForAll(address operator, bool _approved) external;\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n\nabstract contract Ownable is Context {\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// --- ERC721 Full Implementation ---\n\nabstract contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Counters for Counters.Counter;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    string private _name;\n    string private _symbol;\n\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, toString(tokenId))) : \"\";\n    }\n\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n    \n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()), \"ERC721: approve caller is not owner nor approved for all\");\n        _approve(to, tokenId);\n    }\n\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _transfer(from, to, tokenId);\n    }\n\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non-ERC721Receiver implementer\");\n    }\n\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n    \n    function _requireMinted(uint256 tokenId) internal view {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, \"\"), \"ERC721: transfer to non-ERC721Receiver implementer\");\n    }\n\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n        _approve(address(0), tokenId);\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n        _approve(address(0), tokenId);\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n    }\n\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private returns (bool) {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non-ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    \n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    function toString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) { return \"0\"; }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n}\n\n// --- Main LockAndReward Contract ---\n\ncontract LockAndReward is ERC721, Ownable {\n    using Counters for Counters.Counter;\n    Counters.Counter private _tokenIdCounter;\n\n    IGGOToken public immutable rewardToken;\n\n    struct LockInfo {\n        address owner;\n        uint256 amount;\n        uint256 startTime;\n    }\n\n    mapping(uint256 => LockInfo) public lockDetails;\n    uint256 public rewardRatePerSecondPerEth;\n\n    event TokensLocked(address indexed user, uint256 indexed tokenId, uint256 amount);\n    event TokensUnlocked(address indexed user, uint256 indexed tokenId, uint256 lockedAmount, uint256 rewardAmount);\n    event RewardRateChanged(uint256 newRate);\n\n    constructor(address _rewardTokenAddress) ERC721(\"Lock Receipt NFT\", \"LRN\") Ownable() {\n        require(_rewardTokenAddress != address(0), \"Reward token address cannot be zero\");\n        rewardToken = IGGOToken(_rewardTokenAddress);\n        rewardRatePerSecondPerEth = 10**15; // Example: 0.001 GGO per second per ETH\n    }\n\n    function lock() public payable {\n        require(msg.value > 0, \"Lock amount must be greater than zero\");\n        _tokenIdCounter.increment();\n        uint256 newTokenId = _tokenIdCounter.current();\n        _safeMint(msg.sender, newTokenId);\n        lockDetails[newTokenId] = LockInfo({\n            owner: msg.sender,\n            amount: msg.value,\n            startTime: block.timestamp\n        });\n        emit TokensLocked(msg.sender, newTokenId, msg.value);\n    }\n\n    function unlock(uint256 _tokenId) public {\n        require(ownerOf(_tokenId) == msg.sender, \"Unlock caller is not the owner of this NFT\");\n        LockInfo storage currentLock = lockDetails[_tokenId];\n        uint256 rewardAmount = _calculateReward(currentLock.amount, currentLock.startTime);\n        \n        // --- BUG FIX ---\n        // First, save the amount to return in a local variable BEFORE deleting the struct.\n        uint256 amountToReturn = currentLock.amount;\n\n        _burn(_tokenId);\n        delete lockDetails[_tokenId];\n        \n        if (rewardAmount > 0) {\n            rewardToken.mint(msg.sender, rewardAmount);\n        }\n\n        // Now, use the saved local variable to return the funds.\n        (bool sent, ) = msg.sender.call{value: amountToReturn}(\"\");\n        require(sent, \"Failed to send Ether back to the user\");\n\n        emit TokensUnlocked(msg.sender, _tokenId, amountToReturn, rewardAmount);\n    }\n\n    function getLockInfo(uint256 _tokenId) public view returns (LockInfo memory) {\n        require(_exists(_tokenId), \"Token ID does not exist\");\n        return lockDetails[_tokenId];\n    }\n\n    function setRewardRate(uint256 _newRate) public onlyOwner {\n        rewardRatePerSecondPerEth = _newRate;\n        emit RewardRateChanged(_newRate);\n    }\n\n    function _calculateReward(uint256 _amount, uint256 _startTime) internal view returns (uint256) {\n        uint256 lockDuration = block.timestamp - _startTime;\n        return (_amount * lockDuration * rewardRatePerSecondPerEth) / 1e18;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {}
  }
}